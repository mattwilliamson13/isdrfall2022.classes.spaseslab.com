{
  "hash": "c34baeb37c21305a104b01b9008af3f2",
  "result": {
    "markdown": "---\ntitle: \"Combining Tabular and Spatial Data\"\nsubtitle: \"HES 505 Fall 2023: Session 15\"\nauthor: \"Matt Williamson\"\nexecute: \n  eval: true\nformat: \n  revealjs:\n    theme: mytheme.scss\n    slide-number: true\n    show-slide-number: print\n    self-contained: true  \n---\n\n\n\n\n# Today's Plan {background=\"#43464B\" background-image=\"img/slide_14/bison.png\"}\n\n\n## Objectives\n\nBy the end of today, you should be able to:\n\n- Define _spatial analysis_\n\n- Describe the steps in planning a spatial analysis\n\n- Understand the structure of relational databases\n\n- Use attributes and topology to subset data\n\n- Generate new features using geographic data\n\n- Join data based on attributes and location\n\n# What is spatial analysis? {background=\"#9F281A\"}\n\n## What is spatial analysis?\n> \"The process of examining the locations, attributes, and relationships of features in spatial data through overlay and other analytical techniques in order to address a question or gain useful knowledge. Spatial analysis extracts or creates new information from spatial data\".\n<footer>--- ESRI Dictionary</footer>\n\n## What is spatial analysis?\n\n::: columns\n::: {.column width=\"60%\"}\n\n- The process of turning maps into information\n\n- Any- or everything we do with GIS\n\n- The use of computational and statistical algorithms to understand the relations between things that co-occur in space.\n:::\n::: {.column width=\"40%\"}\n![John Snow's cholera outbreak map](img/slide_14/Snow-cholera-map.png)\n:::\n:::\n\n## Common goals for spatial analysis\n\n::: columns\n::: {.column width=\"60%\"}\n![courtesy of [NatureServe](https://www.natureserve.org/products/species-distribution-modeling)](img/slide_14/stand-land_modeling_process_0.png){width=700, height=500}\n:::\n::: {.column width=\"40%\"}\n\n- Describe and visualize locations or events\n\n- Quantify patterns\n\n- Characterize 'suitability'\n\n- Determine (statistical) relations\n:::\n:::\n\n## Common pitfalls of spatial analysis\n\n- __Locational Fallacy:__ Error due to the spatial characterization chosen for elements of study\n\n\n- __Atomic Fallacy:__ Applying conclusions from individuals to entire spatial units\n\n\n- __Ecological Fallacy:__ Applying conclusions from aggregated information to individuals\n\n::: {style=\"font-size: 0.7em\"}\n> Spatial analysis is an inherently complex endeavor and one that is advancing rapidly. So-called \"best practices\" for addressing many of these issues are still being developed and debated. This doesn't mean you shouldn't do spatial analysis, but you should keep these things in mind as you design, implement, and interpret your analyses\n:::\n\n# Workflows for spatial analysis {background=\"#9F281A\"}\n\n## Workflows for spatial analysis\n\n::: columns\n::: {.column width=\"60%\"}\n- Acquisition (not really a focus, but see [Resources](content/resource/))\n\n- Geoprocessing \n\n- Analysis \n\n- Visualization \n:::\n::: {.column width=\"40%\"}\n![courtesy of [University of Illinois](https://guides.library.illinois.edu/c.php?g=348425&p=5443868)](img/slide_14/acquire_analyze_present.png)\n:::\n:::\n\n## Geoprocessing\n\n__Manipulation of data for subsequent use__\n\n- Alignment \n\n- Data cleaning and transformation \n\n- Combination of multiple datasets \n\n- Selection and subsetting \n\n# Databases and Attributes {background=\"#9F281A\"}\n\n## Databases and Attributes\n\n::: columns\n::: {.column width=\"40%\"}\n![courtesy of [Giscommons](https://giscommons.org/data-tables-and-data-preprocessing/)](img/slide_14/4.1.png)\n:::\n::: {.column width=\"60%\"}\n::: {style=\"font-size: 0.7em\"}\n- Attributes: Information that further describes a spatial feature\n\n- Attributes &rightarrow; predictors for analysis \n\n- Last week focus on thematic relations between datasets\n  - Shared 'keys' help define linkages between objects\n\n- Sometimes we are interested in attributes that describe location (overlaps, contains, distance)\n\n- Sometimes we want to join based on location rather than thematic connections\n  - __Must have the same CRS__\n:::\n:::\n:::\n## Databases and attributes\n\n::: columns\n::: {.column width=\"40%\"}\n![courtesy of [Giscommons](https://giscommons.org/data-tables-and-data-preprocessing/)](img/slide_14/4.1.png)\n:::\n::: {.column width=\"60%\"}\n::: {style=\"font-size: 0.7em\"}\n- Previous focus has been largely on _location_\n\n- Geographic data often also includes non-spatial data\n\n- Attributes: Non-spatial information that further describes a spatial feature\n\n- Typically stored in tables where each row represents a spatial feature\n  - Wide vs. long format\n:::\n:::\n:::\n\n## Common attribute operations\n\n- `sf` designed to work with `tidyverse`\n\n- Allows use of `dplyr` data manipulation verbs (e.g. `filter`, `select`, `slice`)\n\n- Can use `scales` package for units\n\n- Also allows `%>%` to chain together multiple steps\n\n- geometries are \"sticky\"\n\n\n## Subsetting by Field\n\n* Fields contain individual attributes\n\n* Selecting fields\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(world)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"     \n```\n:::\n\n```{.r .cell-code}\nhead(world)[,1:3] %>% \n  st_drop_geometry()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  iso_a2 name_long      continent    \n* <chr>  <chr>          <chr>        \n1 FJ     Fiji           Oceania      \n2 TZ     Tanzania       Africa       \n3 EH     Western Sahara Africa       \n4 CA     Canada         North America\n5 US     United States  North America\n6 KZ     Kazakhstan     Asia         \n```\n:::\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nworld %>%\n  dplyr::select(name_long, continent) %>%\n  st_drop_geometry() %>% \n  head(.) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n  name_long      continent    \n  <chr>          <chr>        \n1 Fiji           Oceania      \n2 Tanzania       Africa       \n3 Western Sahara Africa       \n4 Canada         North America\n5 United States  North America\n6 Kazakhstan     Asia         \n```\n:::\n:::\n\n:::\n:::\n\n## Subsetting by Features\n* Features refer to the individual observations in the dataset\n* Selecting features\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(world)[1:3, 1:3] %>% \n  st_drop_geometry()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  iso_a2 name_long      continent\n* <chr>  <chr>          <chr>    \n1 FJ     Fiji           Oceania  \n2 TZ     Tanzania       Africa   \n3 EH     Western Sahara Africa   \n```\n:::\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nworld %>%\n  filter(continent == \"Asia\") %>% \n    dplyr::select(name_long, continent) %>%\n  st_drop_geometry() %>% \n  head(.)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n  name_long   continent\n  <chr>       <chr>    \n1 Kazakhstan  Asia     \n2 Uzbekistan  Asia     \n3 Indonesia   Asia     \n4 Timor-Leste Asia     \n5 Israel      Asia     \n6 Lebanon     Asia     \n```\n:::\n:::\n\n:::\n:::\n\n# Spatial Subsetting {background=\"#9F281A\"}\n\n\n## Topological Subsetting\n::: {style=\"font-size: 0.7em\"}\n- Topological relations describe the spatial relationships between objects\n\n- We can use the overlap (or not) of vector data to subset the data based on topology\n\n- Need _valid_ geometries\n\n- Easiest way is to use `[` notation, but also most restrictive\n:::\n\n::: columns\n::: {.column width=\"60%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ncanterbury = nz  %>% filter(Name == \"Canterbury\")\ncanterbury_height = nz_height[canterbury, ]\n```\n:::\n\n:::\n::: {.column width=\"40%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](15-slides_files/figure-revealjs/unnamed-chunk-6-1.png){width=480}\n:::\n:::\n\n:::\n:::\n\n## Topological Subsetting\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {style=\"font-size: 0.7em\"}\n\n- Lots of verbs in `sf` for doing this (e.g., `st_intersects`, `st_contains`, `st_touches`)\n\n- see `?geos_binary_pred` for a full list\n\n- Creates an __implicit__ attribute (the _records_ in `x` that are \"in\" `y`)\n\n:::\n:::\n::: {.column width=\"50%\"}\n__Using `sparse=TRUE`__\n\n::: {.cell}\n\n```{.r .cell-code}\nco = filter(nz, grepl(\"Canter|Otag\", Name))\nst_intersects(nz_height, co, \n              sparse = TRUE)[1:3] \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\ninteger(0)\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nlengths(st_intersects(nz_height, \n                      co, sparse = TRUE))[1:3] > 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE  TRUE\n```\n:::\n:::\n\n:::\n:::\n\n## Topological Subsetting\n\n- The `sparse` option controls how the results are returned\n- We can then find out if one or more elements satisfies the criteria\n\n__Using `sparse=FALSE`__\n\n::: {.cell}\n\n```{.r .cell-code}\nst_intersects(nz_height, co, sparse = FALSE)[1:3,] \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]  [,2]\n[1,] FALSE FALSE\n[2,] FALSE  TRUE\n[3,] FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\napply(st_intersects(nz_height, co, sparse = FALSE), 1,any)[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE  TRUE\n```\n:::\n:::\n\n\n## Topological Subsetting\n\n::: columns\n::: {.column width=\"60%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ncanterbury_height3 = nz_height %>%\n  filter(st_intersects(x = ., y = canterbury, sparse = FALSE))\n```\n:::\n\n:::\n::: {.column width=\"40%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](15-slides_files/figure-revealjs/unnamed-chunk-8-1.png){width=480}\n:::\n:::\n\n:::\n:::\n\n# New Attributes from Existing Fields {background=\"#9F281A\"}\n\n## Revisiting the `tidyverse` \n\n* Creating new fields \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld %>%\n  filter(continent == \"Asia\") %>% \n    dplyr::select(name_long, continent, pop, gdpPercap ,area_km2) %>%\n  mutate(., dens = pop/area_km2,\n         totGDP = gdpPercap * pop) %>%\n  st_drop_geometry() %>% \n  head(.)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 7\n  name_long   continent       pop gdpPercap area_km2   dens  totGDP\n  <chr>       <chr>         <dbl>     <dbl>    <dbl>  <dbl>   <dbl>\n1 Kazakhstan  Asia       17288285    23587. 2729811.   6.33 4.08e11\n2 Uzbekistan  Asia       30757700     5371.  461410.  66.7  1.65e11\n3 Indonesia   Asia      255131116    10003. 1819251. 140.   2.55e12\n4 Timor-Leste Asia        1212814     6263.   14715.  82.4  7.60e 9\n5 Israel      Asia        8215700    31702.   22991. 357.   2.60e11\n6 Lebanon     Asia        5603279    13831.   10099. 555.   7.75e10\n```\n:::\n:::\n\n\n## Revisiting the `tidyverse` \n\n* Creating new fields \n\n\n::: {.cell}\n::: {.cell-output-display}\n![](15-slides_files/figure-revealjs/unnamed-chunk-10-1.png){width=960}\n:::\n:::\n\n\n## Revisiting the `tidyverse` \n\n* Aggregating data\n\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld %>%\n  st_drop_geometry(.) %>% \n  group_by(continent) %>%\n  summarize(pop = sum(pop, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 × 2\n  continent                      pop\n  <chr>                        <dbl>\n1 Africa                  1154946633\n2 Antarctica                       0\n3 Asia                    4311408059\n4 Europe                   669036256\n5 North America            565028684\n6 Oceania                   37757833\n7 Seven seas (open ocean)          0\n8 South America            412060811\n```\n:::\n:::\n\n\n:::\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](15-slides_files/figure-revealjs/wrldagg-1.png){width=960}\n:::\n:::\n\n\n:::\n:::\n\n# New Attributes from Topology {background=\"#9F281A\"}\n\n## Attributes based on geometry and location (`measures`)\n\n- Attributes like area and length can be useful for a number of analyses\n  - Estimates of 'effort' in sampling designs\n  - Offsets for modeling rates (e.g., Poisson regression)\n  \n- Need to assign the result of the function to a column in data frame (e.g., `$`, `mutate`, and `summarize`)\n\n- Often useful to test before assigning\n\n## Estimating area\n\n::: columns\n::: {.column width=\"60%\"}\n::: {style=\"font-size: 0.7em\"}\n- `sf` bases area (and length) calculations on the map units of the CRS\n\n- the `units` library allows conversion into a variety of units\n\n:::\n:::\n::: {.column width=\"40%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nnz.sf <- nz %>% \n  mutate(area = st_area(nz))\nhead(nz.sf$area, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnits: [m^2]\n[1] 12890576439  4911565037 24588819863\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnz.sf$areakm <- units::set_units(st_area(nz), km^2)\nhead(nz.sf$areakm, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnits: [km^2]\n[1] 12890.576  4911.565 24588.820\n```\n:::\n:::\n\n:::\n:::\n\n## Estimating Density in Polygons\n\n::: columns\n::: {.column width=\"40%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](15-slides_files/figure-revealjs/unnamed-chunk-14-1.png){width=384}\n:::\n:::\n\n:::\n::: {.column width=\"60%\"}\n::: {style=\"font-size: 0.7em\"}\n- Creating new features based on the frequency of occurrence\n\n- Clarifying graphics\n\n- Underlies quadrat sampling for point patterns\n\n- Two steps: count and area\n:::\n:::\n:::\n\n\n## Estimating Density in Polygons\n\n::: columns\n::: {.column width=\"40%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](15-slides_files/figure-revealjs/unnamed-chunk-15-1.png){width=384}\n:::\n:::\n\n:::\n::: {.column width=\"60%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nnz.df <- nz %>% \nmutate(counts = lengths(st_intersects(., random_nz)),\n       area = st_area(nz),\n       density = counts/area)\nhead(st_drop_geometry(nz.df[,7:10]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  counts              area              density\n1     17 12890576439 [m^2] 1.318793e-09 [1/m^2]\n2      6  4911565037 [m^2] 1.221607e-09 [1/m^2]\n3     37 24588819863 [m^2] 1.504749e-09 [1/m^2]\n4     22 12271015945 [m^2] 1.792843e-09 [1/m^2]\n5     12  8364554416 [m^2] 1.434625e-09 [1/m^2]\n6     19 14242517871 [m^2] 1.334034e-09 [1/m^2]\n```\n:::\n:::\n\n:::\n:::\n\n## Estimating Density in Polygons\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](15-slides_files/figure-revealjs/unnamed-chunk-17-1.png){width=384}\n:::\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](15-slides_files/figure-revealjs/unnamed-chunk-18-1.png){width=384}\n:::\n:::\n\n:::\n:::\n## Estimating Distance\n\n- As a covariate\n\n- For use in covariance matrices\n\n- As a means of assigning connections in networks\n\n\n## Estimating Single Point Distance\n\n::: columns\n::: {.column width=\"40%\"}\n- `st_distance` returns distances between all features in `x` and all features in `y`\n\n- One-to-One relationship requires choosing a single point for `y`\n:::\n::: {.column width=\"40%\"}\n![](img/slide_14/types-of-relationship-in-Database.png) \n:::\n:::\n\n## Estimating Single Point Distance\n\n- Subsetting `y` into a single feature\n\n::: columns\n::: {.column width=\"70%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ncanterbury = nz %>% filter(Name == \"Canterbury\")\ncanterbury_height = nz_height[canterbury, ]\nco = filter(nz, grepl(\"Canter|Otag\", Name))\nst_distance(nz_height[1:3, ], co)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnits: [m]\n          [,1]     [,2]\n[1,] 123537.16 15497.72\n[2,]  94282.77     0.00\n[3,]  93018.56     0.00\n```\n:::\n:::\n\n:::\n::: {.column width=\"30%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](15-slides_files/figure-revealjs/unnamed-chunk-20-1.png){width=432}\n:::\n:::\n\n:::\n:::\n\n## Estimating Single Point Distance\n\n- Using nearest neighbor distances\n\n::: columns\n::: {.column width=\"60%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nua <- urban_areas(cb = FALSE, progress_bar = FALSE) %>% \n  filter(., UATYP10 == \"U\") %>% \n  filter(., str_detect(NAME10, \"ID\")) %>% \n  st_transform(., crs=2163)\n\n#get index of nearest ID city\nnearest <-  st_nearest_feature(ua)\n#estimate distance\n(dist = st_distance(ua, ua[nearest,], by_element=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnits: [m]\n[1]  61386.444  61386.444   1646.182   1646.182 136908.183 136908.183\n```\n:::\n:::\n\n:::\n::: {.column width=\"40%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](15-slides_files/figure-revealjs/unnamed-chunk-22-1.png){width=480}\n:::\n:::\n\n:::\n:::\n\n\n# Joining (a)spatial data {background=\"#9F281A\"}\n\n\n## Joining (a)spatial data\n\n::: columns\n::: {.column width=\"40%\"}\n- Requires a \"key\" field \n\n- Multiple outcomes possible\n\n- Think about your final data form\n:::\n::: {.column width=\"60%\"}\n![](img/slide_14/types-of-relationship-in-Database.png) \n:::\n:::\n\n## Left Join\n\n- Useful for adding other attributes not in your spatial data\n\n- Returns all of the records in `x` attributed with `y`\n\n- Pay attention to the number of rows!\n\n## Left Join\n\n\n::: {.cell}\n\n:::\n\n![](img/slide_14/left-join.gif)\n\n## Left Join\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(coffee_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  name_long                coffee_production_2016 coffee_production_2017\n  <chr>                                     <int>                  <int>\n1 Angola                                       NA                     NA\n2 Bolivia                                       3                      4\n3 Brazil                                     3277                   2786\n4 Burundi                                      37                     38\n5 Cameroon                                      8                      6\n6 Central African Republic                     NA                     NA\n```\n:::\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_coffee = left_join(world, coffee_data)\nnrow(world_coffee)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 177\n```\n:::\n:::\n\n:::\n:::\n\n## Left Join\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](15-slides_files/figure-revealjs/unnamed-chunk-26-1.png){width=960}\n:::\n:::\n\n\n## Inner Join\n\n- Useful for subsetting to \"complete\" records\n\n- Returns all of the records in `x` with matching `y`\n\n- Pay attention to the number of rows!\n\n## Inner Join\n\n\n::: {.cell}\n\n:::\n\n![](img/slide_14/inner-join.gif)\n\n## Inner Join\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_coffee_inner = inner_join(world, coffee_data)\nnrow(world_coffee_inner)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 45\n```\n:::\n:::\n\n::: \n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nsetdiff(coffee_data$name_long, world$name_long)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Congo, Dem. Rep. of\" \"Others\"             \n```\n:::\n:::\n\n:::\n:::\n\n## Inner Join\n\n::: {.cell}\n::: {.cell-output-display}\n![](15-slides_files/figure-revealjs/unnamed-chunk-30-1.png){width=960}\n:::\n:::\n\n\n# Spatial Joins {background=\"#9F281A\"}\n\n## Spatial Joins\n\n- `sf` package provides `st_join` for vectors\n\n- Allows joins based on the predicates (`st_intersects`, `st_touches`, `st_within_distance`, etc.)\n\n- Default is a left join\n\n## Spatial Joins\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2018)\n(bb = st_bbox(world)) # the world's bounds\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      xmin       ymin       xmax       ymax \n-180.00000  -89.90000  179.99999   83.64513 \n```\n:::\n\n```{.r .cell-code}\n#>   xmin   ymin   xmax   ymax \n#> -180.0  -89.9  180.0   83.6\nrandom_df = data.frame(\n  x = runif(n = 10, min = bb[1], max = bb[3]),\n  y = runif(n = 10, min = bb[2], max = bb[4])\n)\nrandom_points = random_df |> \n  st_as_sf(coords = c(\"x\", \"y\")) |> # set coordinates\n  st_set_crs(\"EPSG:4326\") # set geographic CRS\n\nrandom_joined = st_join(random_points, world[\"name_long\"])\n```\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](15-slides_files/figure-revealjs/unnamed-chunk-32-1.png){width=960}\n:::\n:::\n\n:::\n:::\n\n## Spatial Joins\n\n- Sometimes we may want to be less restrictive\n\n- Just because objects don't touch doesn't mean they don't relate to each other\n\n- Can use `predicates` in `st_join`\n\n- Remember that default is `left_join` (so the number of records can grow if multiple matches)\n\n## Spatial Joins\n\n::: columns\n::: {.column width=\"70%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nany(st_touches(cycle_hire, cycle_hire_osm, sparse = FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nz = st_join(cycle_hire, cycle_hire_osm, st_is_within_distance, dist = 20)\nnrow(cycle_hire)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 742\n```\n:::\n\n```{.r .cell-code}\nnrow(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 762\n```\n:::\n:::\n\n:::\n::: {.column width=\"30%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](15-slides_files/figure-revealjs/unnamed-chunk-34-1.png){width=960}\n:::\n:::\n\n:::\n:::\n\n# Extending Joins {background=\"#0033A0\"}\n\n## Extending Joins \n::: {style=\"font-size: 0.6em\"}\n- Sometimes we are interested in analyzing locations that contain the overlap between two vectors\n  - How much of home range _a_ occurs on soil type _b_\n  - How much of each Census tract is contained with a service provision area?\n- `st_intersection`, `st_union`, and `st_difference` return new geometries that we can use as records in our spatial database\n:::\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](15-slides_files/figure-revealjs/unnamed-chunk-35-1.png){fig-pos='t' width=960}\n:::\n:::\n\n:::  \n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nintersect_pct <- st_intersection(nc, tr_buff) %>% \n   mutate(intersect_area = st_area(.)) %>%   # create new column with shape area\n   dplyr::select(NAME, intersect_area) %>%   # only select columns needed to merge\n   st_drop_geometry()\n\nnc <- mutate(nc, county_area = st_area(nc))\n\n# Merge by county name\nnc <- merge(nc, intersect_pct, by = \"NAME\", all.x = TRUE)\n\n# Calculate coverage\nnc <- nc %>% \n   mutate(coverage = as.numeric(intersect_area/county_area))\n```\n:::\n\n:::\n:::\n\n## Extending Joins\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](15-slides_files/figure-revealjs/unnamed-chunk-37-1.png){width=960}\n:::\n:::\n",
    "supporting": [
      "15-slides_files/figure-revealjs"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}