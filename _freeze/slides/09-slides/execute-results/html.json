{
  "hash": "53cfd1f7f65c9c93b57ce36e867c4aee",
  "result": {
    "markdown": "---\ntitle: \"Areal Data: Rasters\"\nsubtitle: \"HES 505 Fall 2023: Session 9\"\nauthor: \"Matt Williamson\"\nformat: \n  revealjs:\n    theme: mytheme.scss\n    slide-number: true\n    show-slide-number: print\n    self-contained: true  \n---\n\n\n# Today's Plan {background-image=\"img/slide_9/NEDUS.gif\" background=\"#9F281A\" background-opacity=\"0.7\"}\n\nBy the end of today, you should be able to: \n\n- Access the elements that define a raster\n\n- Build rasters from scratch using matrix operations and `terra`\n\n- Evaluate logical conditions with raster data\n\n- Calculate different measures of raster data\n\n## Revisiting the Raster Data Model\n\n::: columns\n:::{.column width=\"50%\"}\n::: {style=\"font-size: 0.7em\"}\n*   __Vector data__ describe the \"exact\" locations of features on a landscape (including a Cartesian landscape)\n\n* __Raster data__ represent spatially continuous phenomena (`NA` is possible)\n\n* Depict the alignment of data on a regular lattice (often a square)\n  * Operations mimic those for `matrix` objects in `R` \n\n* Geometry is implicit; the spatial extent and number of rows and columns define the cell size\n:::\n:::\n::: {.column width=\"50%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](09-slides_files/figure-revealjs/unnamed-chunk-1-1.png){width=576}\n:::\n:::\n\n:::\n:::\n\n## Rasters with `terra`\n\n* syntax is different for `terra` compared to `sf`\n\n* Representation in `Environment` is also different\n\n* Can break pipes, __Be Explicit__\n\n# Rasters by Construction {background=\"#9F281A\"}\n\n## Rasters by Construction\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmtx <- matrix(1:16, nrow=4)\nmtx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\n```\n:::\n\n```{.r .cell-code}\nrstr <- terra::rast(mtx)\nrstr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass       : SpatRaster \ndimensions  : 4, 4, 1  (nrow, ncol, nlyr)\nresolution  : 1, 1  (x, y)\nextent      : 0, 4, 0, 4  (xmin, xmax, ymin, ymax)\ncoord. ref. :  \nsource(s)   : memory\nname        : lyr.1 \nmin value   :     1 \nmax value   :    16 \n```\n:::\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](09-slides_files/figure-revealjs/unnamed-chunk-3-1.png){width=576}\n:::\n:::\n\n:::\n:::\n::: {style=\"font-size: 0.5em\"}\nNote: you must have `raster` or `terra` loaded for `plot()` to work on `Rast*` objects; otherwise you get `Error in as.double(y) : cannot coerce type 'S4' to vector of type 'double'`\n:::\n\n## Rasters by Construction: Origin\n\n* Origin defines the location of the intersection of the x and y axes\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nr <- rast(xmin=-4, xmax = 9.5, ncols=10)\nr[] <- runif(ncell(r))\norigin(r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.05 0.00\n```\n:::\n\n```{.r .cell-code}\nr2 <- r\norigin(r2) <- c(2,2) \n```\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](09-slides_files/figure-revealjs/unnamed-chunk-5-1.png){width=576}\n:::\n:::\n\n:::\n:::\n\n## Rasters by Construction: Resolution\n::: {style=\"font-size: 0.7em\"}\n* Geometry is implicit; the spatial extent and number of rows and columns define the cell size\n* __Resolution__ (`res`) defines the length and width of an individual pixel\n:::\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nr <- rast(xmin=-4, xmax = 9.5, \n          ncols=10)\nres(r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.35 1.00\n```\n:::\n\n```{.r .cell-code}\nr2 <- rast(xmin=-4, xmax = 5, \n           ncols=10)\nres(r2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.9 1.0\n```\n:::\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nr <- rast(xmin=-4, xmax = 9.5, \n          res=c(0.5,0.5))\nncol(r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 27\n```\n:::\n\n```{.r .cell-code}\nr2 <- rast(xmin=-4, xmax = 9.5, \n           res=c(5,5))\nncol(r2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n:::\n:::\n\n# Predicates and measures in `terra` {background=\"#9F281A\"}\n\n## Extending predicates\n\n- __Predicates__: evaluate a logical statement asserting that a property is `TRUE` \n\n- `terra` does not follow the same hierarchy as `sf` so a little trickier\n\n## Unary predicates in `terra`\n\n* Can tell us qualities of a raster dataset\n\n* Many similar operations for `SpatVector` class (note use of `.`)\n\n::: {style=\"font-size: 0.7em\"}\n|predicate            |asks...                                                  |\n|---------------------|--------------------------------------------------------------|\n|`is.lonlat`             |Does the object have a longitude/latitude CRS?|\n|`inMemory`              |is the object stored in memory?|\n|`is.factor`              |Are there categorical layers?|\n|`hasValues`              |Do the cells have values?|\n:::\n\n## Unary predicates in `terra`\n\n::: columns\n:::{.column width=\"50%\"}\n::: {style=\"font-size: 0.7em\"}\n* `global`: tests if the raster covers all longitudes (from -180 to 180 degrees) such that the extreme columns are in fact adjacent\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr <- rast()\nis.lonlat(r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.lonlat(r, global=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n:::\n:::\n::: {.column width=\"50%\"}\n::: {style=\"font-size: 0.7em\"}\n* `perhaps`: If TRUE and the crs is unknown, the method returns TRUE if the coordinates are plausible for longitude/latitude\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrs(r) <- \"\"\nis.lonlat(r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code}\nis.lonlat(r, perhaps=TRUE, warn=FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncrs(r) <- \"+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +ellps=WGS84\"\nis.lonlat(r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n:::\n:::\n:::\n\n## Binary predicates in `terra`\n\n* Take exactly 2 inputs, return 1 matrix of cell locs where value is `TRUE`\n\n* `adjacent`: identifies cells adajcent to a set of raster cells\n\n![](img/slide_9/cases.gif)\n\n## Unary measures in `terra`\n\n* Slightly more flexible than `sf` \n\n* One result for each layer in a stack\n\n::: {style=\"font-size: 0.5em\"}\n|measure              |returns                                                       |\n|---------------------|--------------------------------------------------------------|\n|`cellSize`          |area of individual cells|\n|`expanse`               |summed area of all cells|\n|`values`             |returns all cell values|\n|`ncol`             |number of columns|\n|`nrow`             |number of rows|\n|`ncell`             |number of cells|\n|`res`             |resolution|\n|`ext`             |minimum and maximum of x and y coords|\n|`origin`             |the orgin of a `SpatRaster`|\n|`crs`             |the coordinate reference system|\n|`cats`             |categories of a categorical raster|\n:::\n\n## Binary measures in `terra`\n\n* Returns a matrix or `SpatRaster` describing the measure\n\n::: {style=\"font-size: 0.5em\"}\n|measure              |returns                                                       |\n|---------------------|--------------------------------------------------------------|\n|`distance`          |shortest distance to non-NA or vector object|\n|`gridDistance`               |shortest distance through adjacent grid cells|\n|`costDistance`             |Shortest distance considering cell-varying friction|\n|`direction`             |azimuth to cells that are not `NA`|\n:::\n",
    "supporting": [
      "09-slides_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}