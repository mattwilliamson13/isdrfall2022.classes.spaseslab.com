{
  "hash": "623a232a33a4d15837a44667a183b536",
  "result": {
    "markdown": "---\ntitle: \"Operations With Vector Data I\"\nsubtitle: \"HES 505 Fall 2023: Session 11\"\nauthor: \"Matt Williamson\"\nformat: \n  revealjs:\n    theme: mytheme.scss\n    slide-number: true\n    show-slide-number: print\n    self-contained: true  \n---\n\n\n# Today's Plan {background=\"#43464B\" background-image=\"img/slide_10/NEDUS.gif\" background-opacity=\"0.7\"}\n\n::: footer\nImage Source: USGS\n:::\n\n## Objectives\n\nBy the end of today, you should be able to:\n\n* Recognize the unary, binary, and n-ary transformers\n\n* Articulate common uses for unary and binary transformers\n\n* Use unary transformations to fix invalid geometries\n\n* Implement common binary transformers to align and combine data\n\n## Revisiting `predicates` and `measures`\n\n- __Predicates__: evaluate a logical statement asserting that a property is `TRUE` \n\n- __Measures__: return a numeric value with units based on the units of the CRS\n\n- Unary, binary, and n-ary distinguish how many geometries each function accepts and returns\n\n## Transformations\n::: {style=\"font-size: 0.7em\"}\n- __Transformations__: create new geometries based on input geometries\n:::\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](11-slides_files/figure-revealjs/unnamed-chunk-1-1.png){width=960}\n:::\n\n::: {.cell-output-display}\n![](11-slides_files/figure-revealjs/unnamed-chunk-1-2.png){width=960}\n:::\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](11-slides_files/figure-revealjs/unnamed-chunk-2-1.png){width=960}\n:::\n:::\n\n:::\n:::\n  \n## Unary Transformations\n\n::: {style=\"font-size: 0.4em\"}\n\n|transformer               |returns a geometry ...                                                              |\n|--------------------------|----------------------------------------------------------------------------------|\n|`centroid`|of type `POINT` with the geometry's centroid|\n|`buffer`|that is larger (or smaller) than the input geometry, depending on the buffer size|\n|`jitter` |that was moved in space a certain amount, using a bivariate uniform distribution|\n|`wrap_dateline`|cut into pieces that do no longer cover the dateline|\n|`boundary`|with the boundary of the input geometry|\n|`convex_hull`|that forms the convex hull of the input geometry|\n|`line_merge`|after merging connecting `LINESTRING` elements of a `MULTILINESTRING` into longer `LINESTRING`s.|\n|`make_valid`|that is valid |\n|`node`|with added nodes to linear geometries at intersections without a node; only works on individual linear geometries|\n|`point_on_surface`|with a (arbitrary) point on a surface|\n|`polygonize`|of type polygon, created from lines that form a closed ring|\n:::\n\n# Common Unary Transformations {background=\"#9F281A\"}\n\n## Fixing geometries\n\n- When `all(st_is_valid(your.shapefile))` returns `FALSE`\n\n::: columns\n::: {.column width=60%}\n::: {style=\"font-size: 0.8em\"}\n- `st_make_valid` has two methods: \n  -   original converts rings into noded lines and extracts polygons\n  -   structured makes rings valid first then merges/subtracts from existing polgyons\n  -   Verify that the output is what you expect!!\n  \n:::\n:::\n::: {.column width=40%}\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\nx = st_sfc(st_polygon(list(rbind(c(0,0),c(0.5,0),c(0.5,0.5),c(0.5,0),c(1,0),c(1,1),c(0,1),c(0,0)))))\nst_is_valid(x)\n```\n````\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](11-slides_files/figure-revealjs/unnamed-chunk-4-1.png){width=576}\n:::\n:::\n\n:::\n:::\n\n## Fixing geometries with `st_make_valid`\n\n::: columns\n::: {.column width=\"40%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](11-slides_files/figure-revealjs/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n:::\n::: {.column width=\"60%}\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\ny <- x %>% st_make_valid()\nst_is_valid(y)\n```\n````\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n:::\n:::\n\n\n## Fixing Geometries with `st_buffer`\n\n::: columns\n:::{.column width=60%}\n-`st_buffer` enforces valid geometries as an output\n\n- Setting a 0 distance buffer leaves most geometries unchanged\n\n- Not all transformations do this\n:::\n:::{.column width=\"40%\"}\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\nz <- x %>% st_buffer(., dist=0)\n\nst_is_valid(z)\n```\n````\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](11-slides_files/figure-revealjs/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n:::\n:::\n\n\n## Changing `CRS` with `st_transform`\n\n- You've already been using this!!\n\n- Does not guarantee valid geometries (use `check = TRUE` if you want this)\n\n- We'll try to keep things from getting too complicated\n\n\n::: {.cell hash='11-slides_cache/revealjs/unnamed-chunk-9_96e7057c24f97e19390fab0287488cba'}\n\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](11-slides_files/figure-revealjs/unnamed-chunk-10-1.png){fig-align='center' width=1344}\n:::\n:::\n\n\n## Converting areas to points with `st_centroid` or `st_point_on_surface` \n\n::: columns\n::: {.column width=\"30%\"}\n::: {style=\"font-size: 0.8em\"}\n- For \"sampling\" other datasets\n\n- To simplify distance calculations\n\n- To construct networks\n:::\n:::\n:::{.column width=\"70%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nid.counties <- tigris::counties(state = \"ID\", progress_bar=FALSE)\nid.centroid <- st_centroid(id.counties)\nid.pointonsurf <- st_point_on_surface(id.counties)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](11-slides_files/figure-revealjs/unnamed-chunk-12-1.png){width=960}\n:::\n:::\n\n:::\n:::\n## Creating \"sampling areas\" \n\n- Uncertainty in your point locations\n\n- Incorporate a fixed range around each point\n\n- Combine multiple points into a single polygon\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhospitals.id <- landmarks.id.csv %>% \n  st_as_sf(., coords = c(\"longitude\", \"lattitude\")) %>% \n  filter(., MTFCC == \"K1231\")\nst_crs(hospitals.id) <- 4326\n```\n:::\n\n\n\n## Creating sampling areas\n\n::: {.cell}\n\n```{.r .cell-code}\nhospital.buf <- hospitals.id %>%\n  st_buffer(., dist=10000)\n\nhospital.mcp <- hospitals.id %>% \n  st_convex_hull(.)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](11-slides_files/figure-revealjs/unnamed-chunk-16-1.png){width=960}\n:::\n:::\n\n\n## Other Unary Transformations \n\n::: {style=\"font-size: 0.4em\"}\n|transformer               |returns a geometry ...                                                              |\n|--------------------------|----------------------------------------------------------------------------------|\n|`segmentize`|a (linear) geometry with nodes at a given density or minimal distance|\n|`simplify`|simplified by removing vertices/nodes (lines or polygons)|\n|`split`|that has been split with a splitting linestring|\n|`transform`|transformed or convert to a new coordinate reference system (chapter \\@ref(cs))|\n|`triangulate`|with Delauney triangulated polygon(s) (figure \\@ref(fig:vor))|\n|`voronoi`|with the Voronoi tessellation of an input geometry (figure \\@ref(fig:vor))|\n|`zm`|with removed or added `Z` and/or `M` coordinates|\n|`collection_extract`|with subgeometries from a `GEOMETRYCOLLECTION` of a particular type|\n|`cast`|that is converted to another type|\n|`+`|that is shifted over a given vector|\n|`*`|that is multiplied by a scalar or matrix|\n:::\n\n# Binary Transformers {background=\"#9F281A\"}\n\n## Binary Transformers\n::: {style=\"font-size: 0.4em\"}\n\n|function           |returns                                                    |infix operator|\n|-------------------|-----------------------------------------------------------|:------------:|\n|`intersection`     |the overlapping geometries for pair of geometries          |`&`|\n|`union`            |the combination of the geometries; removes internal boundaries and duplicate points, nodes or line pieces|`|`|\n|`difference`       |the geometries of the first after removing the overlap with the second geometry|`/`|\n|`sym_difference`   |the combinations of the geometries after removing where they intersect; the negation (opposite) of `intersection`|`%/%`|\n| `crop`            | crop an sf object to a specific rectangle |\n:::\n\n## Binary Transformers\n![](img/slide_9/venn-clip-1.png)\n\n## Common Uses of Binary Transformers\n\n* Relating partially overlapping datasets to each other\n\n* Reducing the extent of vector objects\n\n## N-ary Transformers\n\n* Similar to Binary (except `st_crop`)\n\n* `union` can be applied to a set of geometries to return its\ngeometrical union\n\n* `intersection` and `difference` take a single argument,\nbut operate (sequentially) on all pairs, triples, quadruples, etc.\n\n\n  \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}