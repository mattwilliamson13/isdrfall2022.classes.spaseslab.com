{
  "hash": "55f2818cd7b576acb476beef9fc09c03",
  "result": {
    "markdown": "---\ntitle: \"Reading Spatial Data in R\"\nsubtitle: \"HES 505 Fall 2023: Session 4\"\nauthor: \"Matt Williamson\"\nformat: \n  revealjs:\n    theme: mytheme.scss\n    slide-number: true\n    show-slide-number: print\n    self-contained: true  \n---\n\n\n## Objectives\n\n1. Revisit the components of spatial data\n\n2. Describe some of the key considerations for thinking about spatial data\n\n3. Introduce the two primary `R` packages for spatial workflows\n\n4. Learn to read and explore spatial objects in `R`\n\n## Describing Absolute Locations\n\n- **Coordinates:** 2 or more measurements that specify location relative to a _reference system_\n\n::: columns\n::: {.column width=\"60%\"}\n::: {style=\"font-size: 0.8em\"} \n- Cartesian coordinate system\n\n- _origin (O)_ = the point at which both measurement systems intersect\n\n- Adaptable to multiple dimensions (e.g. *z* for altitude)\n:::\n:::\n::: {.column width=\"40%\"}\n![Cartesian Coordinate System](img/slide_3/CartesianCoordinateSystem.png)\n:::\n:::\n\n## Locations on a Globe\n\n- The earth is not flat...\n\n\n![Latitude and Longitude](img/slide_6/Latitude_and_Longitude.png)\n\n## Locations on a Globe\n\n- The earth is not flat...\n\n- Global Reference Systems (GRS)\n\n- _Graticule_: the grid formed by the intersection of longitude and latitude\n\n- The graticule is based on an ellipsoid model of earth's surface and contained in the _datum_\n\n\n## Global Reference Systems\n::: {style=\"font-size: 1.2em; text-align: center\"}\n__The *datum* describes which ellipsoid to use and the precise relations between locations on earth's surface and Cartesian coordinates__\n:::\n\n- Geodetic datums (e.g., `WGS84`): distance from earth's center of gravity\n\n- Local data (e.g., `NAD83`): better models for local variation in earth's surface\n\n## Describing location: extent\n::: incremental\n- How much of the world does the data cover?\n\n- For rasters, these are the corners of the lattice\n\n- For vectors, we call this the bounding box\n:::\n\n## Describing location: resolution\n\n::: columns\n::: {.column width=\"40%\"}\n::: incremental\n-   **Resolution:** the accuracy that the location and shape of a map's features can be depicted\n\n-   **Minimum Mapping Unit:** The minimum size and dimensions that can be reliably represented at a given _map scale_. \n\n-   Map scale vs. scale of analysis\n:::\n:::\n::: {.column width=\"60%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](04-slides_files/figure-revealjs/unnamed-chunk-1-1.png){width=960}\n:::\n:::\n\n\n:::\n:::\n# {background=\"#9F281A\"}\n:::{style=\"font-size: 1.4em; text-align: middle; margin-top: 2em\"}\nThe earth is not flat...\n:::\n\n## Projections\n\n::: columns\n::: {.column width=\"60%\"}\n::: {style=\"font-size: 0.8em\"} \n- But maps, screens, and publications are...\n\n- **Projections** describe *how* the data should be translated to a flat surface\n\n- Rely on 'developable surfaces'\n\n- Described by the Coordinate Reference System (CRS)\n:::\n:::\n::: {.column width=\"40%\"}\n![Developable Surfaces](img/slide_3/projections.png)\n:::\n::: \n \n::: {style=\"font-size: 1.1em; text-align: center\"}\n[__Projection necessarily induces some form of distortion (tearing, compression, or shearing)__]{style=\"color:#771C6D\"}\n:::\n\n\n## Coordinate Reference Systems\n\n::: {style=\"font-size: 0.8em\"}\n\n-   Some projections minimize distortion of angle, area, or distance\n\n-   Others attempt to avoid extreme distortion of any kind \n\n-   Includes: Datum, ellipsoid, units, and other information (e.g., False Easting, Central Meridian) to further map the projection to the GCS\n\n-   Not all projections have/require all of the parameters\n:::\n\n\n::: {.cell hash='04-slides_cache/revealjs/unnamed-chunk-2_17940f2e7a603c37f9a5a435f0a60673'}\n::: {.cell-output-display}\n![](04-slides_files/figure-revealjs/unnamed-chunk-2-1.png){width=960}\n:::\n:::\n\n## Choosing Projections\n::: columns\n::: {.column width=\"40%\"}\n![](img/slide_3/distortion.png)\n:::\n::: {.column width=\"60%\"}\n\n- Equal-area for thematic maps\n\n- Conformal for presentations\n\n- Mercator or equidistant for navigation and distance\n\n:::\n:::\n\n# {background=\"#9F281A\"}\n:::{style=\"font-size: 1.4em; text-align: middle; margin-top: 2em\"}\nGeometries, support, and spatial messiness\n:::\n\n## Geometries\n\n::: columns\n::: {.column width=\"40%\"}\n-   Vectors store aggregate the locations of a feature into a geometry\n-   Most vector operations require simple, valid geometries\n:::\n::: {.column width=\"60%\"}\n![Image Source: Colin Williams (NEON)](img/slide_3/points-lines-polygons-vector-data-types.png)\n:::\n:::\n\n## Valid Geometries\n::: {style=\"font-size: 0.8em\"} \n-   A `linestring` is _simple_ if it does not intersect\n-   Valid polygons\n  -   Are closed (i.e., the last vertex equals the first)\n  -   Have holes (inner rings) that inside the the exterior boundary\n  -   Have holes that touch the exterior at no more than one vertex (they don't extend across a line)\n    -   For multipolygons, adjacent polygons touch only at points\n  -   Do not repeat their own path\n\n:::\n\n##\n\n::: {.cell}\n::: {.cell-output-display}\n![](04-slides_files/figure-revealjs/unnamed-chunk-3-1.png){width=960}\n:::\n:::\n\n\n\n## Empty Geometries\n\n* Empty geometries arise when an operation produces `NULL` outcomes (like looking for the intersection between two non-intersecting polygons)\n\n* `sf` allows empty geometries to make sure that information about the data type is retained\n\n* Similar to a `data.frame` with no rows or a `list` with `NULL` values\n\n* Most vector operations require simple, valid geometries\n\n\n## Support\n* __Support__ is the area to which an attribute applies.\n\n::: incremental\n\n*   For vectors, the attribute-geometry-relationship can be:\n  *   __constant__ = applies to every point in the geometry (lines and polygons are just lots of points)\n  *   __identity__ = a value unique to a geometry\n  *   __aggregate__ = a single value that integrates data across the geometry\n\n*   Rasters can have __point__ (attribute refers to the cell center) or __cell__ (attribute refers to an area similar to the pixel) support\n\n:::\n\n## Spatial Messiness\n\n* Quantitative geography requires that our data are aligned\n\n* Achieving alignment is part of reproducible workflows\n\n* Making principled decisions about projections, resolution, extent, etc\n\n\n# Mapping Location in `R` {background=\"#9F281A\"}\n\n## Data Types and `R` Packages\n\n::: columns\n::: {.column width=\"60%\"}\n### Data Types\n\n- Vector Data\n  - Point features\n  - Line features\n  - Area features (polygons)\n\n- Raster Data\n  - Spatially continuous field\n  - Based on pixels (not points)\n:::\n::: {.column width=\"30%\"}\n![](img/slide_4/sf_hexagon.png)\n\n![](img/slide_4/terra_hexagon.png){height=72%, width=72%}\n\n:::\n:::\n\n## Reading in Spatial Data: spreadsheets\n\n::: {style=\"font-size: 0.8em\"} \n- Most basic form of spatial data\n\n- Need `x` (longitude) and `y` (latitude) as columns\n\n- Need to know your CRS\n\n- `read_***` necessary to bring in the data\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(sf)\n\nfile.to.read <- read_csv(file = \"path/to/your/file\", \n                         col_names = TRUE, col_types = NULL, \n                         na =na = c(\"\", \"NA\"))\n\nfile.as.sf <- st_as_sf(file.to.read, \n                       coords = c(\"longitude\", \"latitude\"), \n                       crs=4326)\n```\n:::\n\n\n## Reading in Spatial Data: shapefiles\n- **ALL FILES NEED TO BE IN THE SAME FOLDER**\n\n::: columns\n::: {.column width=\"40%\"}\n::: {style=\"font-size: 0.8em\"} \n- `.shp` is the shapefile itself\n- `.prj` contains the CRS information\n- `.dbf` contains the attributes\n- `.shx` contains the indices for matching attributes to geometries\n- other extensions contain metadata\n\n:::\n:::\n::: {.column width=\"60%\"}\n::: incremental\n\n-   `st_read` and `read_sf` in the `sf` package will read shapefiles into `R`\n\n-   `read_sf` leaves character vectors alone (often beneficial)\n\n-   `st_read` can handle other datatypes (like geodatabases)\n\n-   Returns slightly different `classes`\n\n:::\n:::\n:::\n\n## Reading in Spatial Data: shapefiles\n\n::: columns\n::: {.column width=\"70%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nshapefile.inR <- read_sf(dsn = \"path/to/file.shp\", \n                         layer=NULL, geometry_column=...)\n```\n:::\n\n:::\n::: {.column width=30%}\n\n![](img/slide_4/sf_hexagon.png)\n\n:::\n:::\n\n## Reading in Spatial Data: rasters\n\n- `rast` will read rasters using the `terra` package\n\n-   Also used to create rasters from scratch\n\n-   Returns `SpatRaster` object\n\n\n::: columns\n::: {.column width=\"70%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nraster.inR <- rast(x = \"path/to/file.shp\", \n                         lyrs=NULL)\n```\n:::\n\n:::\n::: {.column width=30%}\n\n![](img/slide_4/terra_hexagon.png)\n\n:::\n:::\n\n## Introducing the Data\n\n- Good idea to get to know your data before manipulating it\n\n- `str`, `summary`, `nrow`, `ncol` are good places to start\n\n- `st_crs` (for `sf` class objects) and `crs` (for `SpatRaster` objects)\n\n- We'll practice a few of these now...\n\n\n## Saving your data\n\n- `write_sf` for `sf` objects; `writeRaster` for `SpatRasters`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(terra)\n\nwrite_sf(object = object.to.save, dsn = \"path/to/save/object\", append = FALSE)\nwriteRaster(x=object, filename = \"path/to/save\")\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}