{
  "hash": "86f7f58a9549de2ba0ee57e395290ff4",
  "result": {
    "markdown": "---\ntitle: \"Areal Data: Vector Data\"\nsubtitle: \"HES 505 Fall 2023: Session 8\"\nauthor: \"Matt Williamson\"\nformat: \n  revealjs:\n    theme: mytheme.scss\n    slide-number: true\n    show-slide-number: print\n    self-contained: true  \n---\n\n\n# Today's Plan {background-image=\"img/slide_8/Hyde_Park-Kenwood_map.jpg\" background-opacity=\"0.7\"}\n\n::: footer\nImage Source: Wikimedia Commons\n:::\n\n## Objectives\n\nBy the end of today, you should be able to: \n\n- Understand `predicates` and `measures` in the context of spatial operations in `sf`\n\n- Define valid geometries and approaches for assessing geometries in `R`\n\n- Use `st_*` and `sf_*` to evaluate attributes of geometries and calculate measurements\n\n# Understanding the language {background=\"#9F281A\"}\n\n## Revisiting Simple Features\n::: columns\n::: {.column width=\"40%\"}\n::: {style=\"font-size: 0.7em\"} \n- The `sf` package relies on a simple feature data model to represent geometries\n  - hierarchical\n  - standardized methods\n  - complementary binary and human-readable encoding\n:::\n:::\n::: {.column width=\"60%\"}\n::: {style=\"font-size: 0.5em\"} \n| type                      | description                                                               |\n|---------------------------|---------------------------------------------------------------------------|\n| `POINT`                   | single point geometry |\n| `MULTIPOINT`              | set of points |\n| `LINESTRING`              | single linestring (two or more points connected by straight lines) |\n| `MULTILINESTRING`         | set of linestrings |\n| `POLYGON`                 | exterior ring with zero or more inner rings, denoting holes |\n| `MULTIPOLYGON`            | set of polygons |\n| `GEOMETRYCOLLECTION`      | set of the geometries above  |\n:::\n:::\n:::\n\n## Revisiting Simple Features\n- You already know how to access some elements of a simple feature\n\n- `st_crs` - returns the coordinate reference system\n\n- `st_bbox` - returns the bounding box for the simple feature\n\n## Standaridized Methods\n:::{style=\"font-size: 0.8em; text-align: middle\"}\nWe can categorize `sf` operations based on what they return and/or how many geometries they accept as input.\n:::\n::: columns\n::: {.column width=\"50%\"}\n::: {style=\"font-size: 0.7em\"} \n- *Output Categories*\n  - __Predicates__: evaluate a logical statement asserting that a property is `TRUE` \n\n  - __Measures__: return a numeric value with units based on the units of the CRS\n\n  - __Transformations__: create new geometries based on input geometries.\n:::\n:::\n::: {.column width=\"50%\"}\n::: {style=\"font-size: 0.7em\"}\n- *Input Geometries*\n\n  - __Unary__: operate on a single geometry at a time (meaning that if you have a `MULTI*` object the function works on each geometry individually)\n  - __Binary__: operate on pairs of geometries\n  - __n-ary__: operate on sets of geometries\n:::\n:::\n:::\n\n# Valid Geometries {background=\"#9F281A\"}\n\n## Remembering Valid Geometries\n::: {style=\"font-size: 0.7em\"} \n- A `linestring` is _simple_ if it does not intersect\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(tidyverse)\nls = st_linestring(rbind(c(0,0), c(1,1),  c(2,2), c(2,1), c(3,4)))\n\nls2 = st_linestring(rbind(c(0,0), c(1,1),  c(2,2), c(0,2), c(1,1), c(2,0)))\n```\n:::\n\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](08-slides_files/figure-revealjs/unnamed-chunk-2-1.png){width=480}\n:::\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](08-slides_files/figure-revealjs/unnamed-chunk-3-1.png){width=480}\n:::\n:::\n\n:::\n:::\n\n## Remembering Valid Geometries\n\n\n- Valid polygons\n  - Are closed (i.e., the last vertex equals the first)\n  - Have holes (inner rings) that inside the the exterior boundary\n  - Have holes that touch the exterior at no more than one vertex (they don't extend across a line)\n    - For multipolygons, adjacent polygons touch only at points\n  - Do not repeat their own path\n\n## Remembering Valid Geometries\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 = st_as_sfc(\"POLYGON((0 0, 0 10, 10 0, 10 10, 0 0))\")\np2 = st_as_sfc(\"POLYGON((0 0, 0 10, 5 5,  0 0))\")\np3 = st_as_sfc(\"POLYGON((5 5, 10 10, 10 0, 5 5))\")\n```\n:::\n\n\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](08-slides_files/figure-revealjs/unnamed-chunk-5-1.png){width=960}\n:::\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](08-slides_files/figure-revealjs/unnamed-chunk-6-1.png){width=960}\n:::\n:::\n\n:::\n:::\n\n\n## Remembering Valid Geometries\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1\"}\np4 = st_as_sfc(c(\"POLYGON((0 0, 0 10, 5 5,  0 0))\", \"POLYGON((5 5, 10 10, 10 0, 5 5))\"))\nplot(p4, col=c( \"#7C4A89\", \"blue\"))\n```\n\n::: {.cell-output-display}\n![](08-slides_files/figure-revealjs/unnamed-chunk-7-1.png){width=960}\n:::\n:::\n\n\n\n## Empty Geometries\n\n* Empty geometries arise when an operation produces `NULL` outcomes (like looking for the intersection between two non-intersecting polygons)\n\n* `sf` allows empty geometries to make sure that information about the data type is retained\n\n* Similar to a `data.frame` with no rows or a `list` with `NULL` values\n\n* Most vector operations require simple, valid geometries\n\n# Predicates {background=\"#9F281A\"}\n\n## Using Unary Predicates\n\n* Unary predicates accept single geometries (or geometry collections)\n* Provide helpful ways to check whether your data is ready to analyze\n* Use the `st_` prefix and return `TRUE/FALSE`\n\n::: {style=\"font-size: 0.5em\"}\n|predicate            |asks...                                                  |\n|---------------------|--------------------------------------------------------------|\n|`is_simple`             |is the geometry self-intersecting (i.e., simple)?|\n|`is_valid`              |is the geometry valid?|\n|`is_empty`              |is the geometry column of an object empty?|\n|`is_longlat`            |does the object have geographic coordinates? (`FALSE` if coords are projected, `NA` if no `crs`)|\n|`is(geometry, class)` | is the geometry of a particular class?|\n:::\n\n## Checking Geometries With Unary Predicates\n\n* Before conducting costly analyses, it's worth checking for:\n\n::: {style=\"font-size: 0.7em\"}\n1. empty geometries, using `any(st_is_empty(x)))`\n2. corrupt geometries, using `any(is.na(st_is_valid(x)))`\n3. invalid geometries, using `any(na.omit(st_is_valid(x)) == FALSE)`; in case of corrupt and/or invalid geometries,\n4. in case of invalid geometries, query the reason for invalidity by `st_is_valid(x, reason = TRUE)`\n:::\n\nInvalid geometries will require __transformation__ (next week!)\n\n## Checking Geometries With Unary Predicates\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](08-slides_files/figure-revealjs/unnamed-chunk-8-1.png){width=960}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nst_is_simple(ls)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nst_is_simple(ls2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](08-slides_files/figure-revealjs/unnamed-chunk-10-1.png){width=960}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nst_is_valid(p1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nst_is_valid(p4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE TRUE\n```\n:::\n:::\n\n:::\n:::\n\n## Unary Predicates and Real Data\n\n::: columns\n::: {.column width=\"40%\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"4,5,6\"}\nlibrary(tigris)\nid.cty <- counties(\"ID\", \n                   progress_bar=FALSE)\nst_crs(id.cty)$input\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"NAD83\"\n```\n:::\n\n```{.r .cell-code  code-line-numbers=\"4,5,6\"}\nst_is_longlat(id.cty)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code  code-line-numbers=\"4,5,6\"}\nst_is_valid(id.cty)[1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE TRUE TRUE TRUE TRUE\n```\n:::\n\n```{.r .cell-code  code-line-numbers=\"4,5,6\"}\nall(st_is_valid(id.cty))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n:::\n::: {.column width=\"60%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](08-slides_files/figure-revealjs/unnamed-chunk-13-1.png){width=576}\n:::\n:::\n\n:::\n:::\n\n# Binary Predicates {background=\"#9F281A\"}\n\n## Binary Predicates\n::: {style=\"font-size: 0.7em\"}\n* Accept exactly two geometries (or collections)\n* Also return `logical` outcomes\n* Based on the Dimensionally Extended 9-Intersection Model (DE-9IM) \n:::\n::: {style=\"font-size: 0.4em\"}\n|predicate                   |meaning                                                          |inverse of      |\n|----------------------------|-----------------------------------------------------------------|----------------|\n|`contains`                  |None of the points of A are outside B| `within`|\n|`contains_properly`         |A contains B and B has no points in common with the boundary of A| |\n|`covers`                    |No points of B lie in the exterior of A| `covered_by`|\n|`covered_by`                |Inverse of `covers`| |\n|`crosses`                   |A and B have some but not all interior points in common| |\n|`disjoint`                  |A and B have no points in common| `intersects`|\n|`equals`                    |A and B are topologically equal: node order or number of nodes may differ; identical to A contains B AND A within B|\n|`equals_exact`              |A and B are geometrically equal, and have identical node order| |\n|`intersects`                |A and B are not disjoint| `disjoint`|\n|`is_within_distance`        |A is closer to B than a given distance|\n|`within`                    |None of the points of B are outside A| `contains`|\n|`touches`                   |A and B have at least one boundary point in common, but no interior points|  |\n|`overlaps`                  |A and B have some points in common; the dimension of these is identical to that of A and B|  |\n|`relate`                    |given a mask [pattern](https://en.wikipedia.org/wiki/DE-9IM), return whether A and B adhere to this pattern| |\n:::\n\n## Binary Predicates\n\n::: columns\n::: {.column width=\"40%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nid <- states(progress_bar=FALSE) %>% \n  filter(STUSPS == \"ID\")\nor <- states(progress_bar=FALSE) %>% \n  filter(STUSPS == \"OR\")\nada.cty <- id.cty %>% \n  filter(NAME == \"Ada\")\n```\n:::\n\n:::\n::: {.column width=\"60%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nst_covers(id, ada.cty)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSparse geometry binary predicate list of length 1, where the predicate\nwas `covers'\n 1: 1\n```\n:::\n\n```{.r .cell-code}\nst_covers(id, ada.cty, sparse=FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,] TRUE\n```\n:::\n\n```{.r .cell-code}\nst_within(ada.cty, or)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSparse geometry binary predicate list of length 1, where the predicate\nwas `within'\n 1: (empty)\n```\n:::\n\n```{.r .cell-code}\nst_within(ada.cty, or, sparse=FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]\n[1,] FALSE\n```\n:::\n:::\n\n:::\n:::\n# Measures {background=\"#9F281A\"}\n\n## Measures\n\n**Unary Measures**\n  \n  * Return quantities of individual geometries\n  \n::: {style=\"font-size: 0.5em\"}\n|measure              |returns                                                       |\n|---------------------|--------------------------------------------------------------|\n|`dimension`          |0 for points, 1 for linear, 2 for polygons, possibly `NA` for empty geometries|\n|`area`               |the area of a geometry|\n|`length`             |the length of a linear geometry|\n:::\n\n**Unary Measures**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_area(id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2.15994e+11 [m^2]\n```\n:::\n\n```{.r .cell-code}\nst_area(id.cty[1:5,])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnits: [m^2]\n[1] 2858212132 3380630278 1459359818 1726660484 1223521586\n```\n:::\n\n```{.r .cell-code}\nst_dimension(id.cty[1:5,])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 2 2 2 2\n```\n:::\n:::\n\n\n## Binary Measures\n  \n  * `st_distance` returns the distance between pairs of geometries\n  \n\n::: {.cell}\n\n```{.r .cell-code}\nkootenai.cty <- id.cty %>% \n  filter(NAME == \"Kootenai\")\nst_distance(kootenai.cty, ada.cty)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnits: [m]\n         [,1]\n[1,] 396433.8\n```\n:::\n\n```{.r .cell-code}\nst_distance(id.cty)[1:5, 1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnits: [m]\n         [,1]     [,2]     [,3]     [,4]     [,5]\n[1,]      0.0 467635.7 277227.0 132998.0      0.0\n[2,] 467635.7      0.0 319706.4 656056.0 514306.9\n[3,] 277227.0 319706.4      0.0 377105.4 336146.8\n[4,] 132998.0 656056.0 377105.4      0.0 133045.5\n[5,]      0.0 514306.9 336146.8 133045.5      0.0\n```\n:::\n:::",
    "supporting": [
      "08-slides_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}